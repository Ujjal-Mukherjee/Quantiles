}
}
D.vec = exp(-Fuxu.vec)
par(mfrow=c(1,2))
persp(pts, pts, matrix(D.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(D.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
sig = matrix(c(1,.5,.5,1), nrow=2)
sig2 = matrix(c(1,-.5,-.5,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(3,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(-3,0), Sigma=sig2)
X = rbind(X1,X2)
# define grid of points
pts = seq(-5,5,by=.5)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
# my PQD
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=100)
for(iu in 1:100){
u = rnorm(2); u = u/sqrt(sum(u^2))
uecdf = ecdf(X%*%u)
Fuxu.mat[,iu] = uecdf(xygrid%*%u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
npt = dim(xygrid)[1]
Fuxu.vec = rep(0,npt)
for(i in 1:npt){
iu = xygrid[i,]; norm.iu = sqrt(sum(iu^2))
if(norm.iu>0){
uecdf = ecdf(X%*%iu)
Fuxu.vec[i] = uecdf(xygrid[i,]%*%iu)
}
else{
Fuxu.vec[i] = .5
}
}
D.vec = exp(-Fuxu.vec)
par(mfrow=c(1,2))
persp(pts, pts, matrix(D.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(D.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
sig = matrix(c(1,.5,.5,1), nrow=2)
sig2 = matrix(c(1,-.5,-.5,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(2,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(-2,0), Sigma=sig2)
X = rbind(X1,X2)
# define grid of points
pts = seq(-5,5,by=.5)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
# my PQD
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=100)
for(iu in 1:100){
u = rnorm(2); u = u/sqrt(sum(u^2))
uecdf = ecdf(X%*%u)
Fuxu.mat[,iu] = uecdf(xygrid%*%u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
sig = matrix(c(1,.5,.5,1), nrow=2)
sig2 = matrix(c(1,-.5,-.5,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(2,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(-2,0), Sigma=sig2)
X = rbind(X1,X2)
# define grid of points
pts = seq(-5,5,by=.5)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
# my PQD
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=100)
for(iu in 1:100){
u = rnorm(2); u = u/sqrt(sum(u^2))
uecdf = ecdf(X%*%u)
Fuxu.mat[,iu] = uecdf(xygrid%*%u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
npt = dim(xygrid)[1]
Fuxu.vec = rep(0,npt)
for(i in 1:npt){
iu = xygrid[i,]; norm.iu = sqrt(sum(iu^2))
if(norm.iu>0){
uecdf = ecdf(X%*%iu)
Fuxu.vec[i] = uecdf(xygrid[i,]%*%iu)
}
else{
Fuxu.vec[i] = .5
}
}
D.vec = exp(-Fuxu.vec)
par(mfrow=c(1,2))
persp(pts, pts, matrix(D.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(D.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
sig = matrix(c(1,.5,.5,1), nrow=2)
sig2 = matrix(c(1,-.5,-.5,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(1,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(-1,0), Sigma=sig2)
X = rbind(X1,X2)
# define grid of points
pts = seq(-5,5,by=.5)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
# my PQD
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=100)
for(iu in 1:100){
u = rnorm(2); u = u/sqrt(sum(u^2))
uecdf = ecdf(X%*%u)
Fuxu.mat[,iu] = uecdf(xygrid%*%u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
sig = matrix(c(1,.5,.5,1), nrow=2)
sig2 = matrix(c(1,-.5,-.5,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(1,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(-1,0), Sigma=sig2)
X = rbind(X1,X2)
# define grid of points
pts = seq(-5,5,by=.5)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
# my PQD
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=100)
for(iu in 1:100){
u = rnorm(2); u = u/sqrt(sum(u^2))
uecdf = ecdf(X%*%u)
Fuxu.mat[,iu] = uecdf(xygrid%*%u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
sig = matrix(c(1,.5,.5,1), nrow=2)
sig2 = matrix(c(1,-.5,-.5,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(1,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(-1,0), Sigma=sig2)
X = rbind(X1,X2)
# define grid of points
pts = seq(-5,5,by=.5)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
# my PQD
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=100)
for(iu in 1:100){
u = rnorm(2); u = u/sqrt(sum(u^2))
uecdf = ecdf(X%*%u)
Fuxu.mat[,iu] = uecdf(xygrid%*%u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
sig = matrix(c(1,.5,.5,1), nrow=2)
sig2 = matrix(c(1,-.5,-.5,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(1,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(-1,0), Sigma=sig2)
X = rbind(X1,X2)
# define grid of points
pts = seq(-5,5,by=.5)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
# my PQD
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=100)
for(iu in 1:100){
u = rnorm(2); u = u/sqrt(sum(u^2))
uecdf = ecdf(X%*%u)
Fuxu.mat[,iu] = uecdf(xygrid%*%u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
npt = dim(xygrid)[1]
Fuxu.vec = rep(0,npt)
for(i in 1:npt){
iu = xygrid[i,]; norm.iu = sqrt(sum(iu^2))
if(norm.iu>0){
uecdf = ecdf(X%*%iu)
Fuxu.vec[i] = uecdf(xygrid[i,]%*%iu)
}
else{
Fuxu.vec[i] = .5
}
}
D.vec = exp(-Fuxu.vec)
par(mfrow=c(1,2))
persp(pts, pts, matrix(D.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(D.vec, nrow=lengrid, byrow=T),
lwd=2, col="red")
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
library(inline)
library(Rcpp)
library(RcppArmadillo)
library(RcppEigen)
sourceCpp("ProjQuantNew.cpp", verbose=TRUE, rebuild=FALSE);
setwd("C:/Study/My projects/Quantiles/Codes/SBM")
rm(list=ls());
library(inline)
library(Rcpp)
library(RcppArmadillo)
library(RcppEigen)
sourceCpp("ProjQuantNew.cpp", verbose=TRUE, rebuild=FALSE);
rm(list=ls());
library(inline)
library(Rcpp)
library(RcppArmadillo)
library(RcppEigen)
sourceCpp("ProjQuantNew.cpp", verbose=TRUE, rebuild=FALSE);
require(cepp)
data(Colon)
n = length(Colon$Y)
n
require(cepp)
data(Colon)
n = length(Colon$Y)
depth.vec = rep(0,n)
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(Colon$X[-i,], Colon$X[i,], .9)
}
depth.vec
dim(Colon$X)
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(Colon$X[-i,], Colon$X[i,], .2)
}
depth.vec
for(i in 1:n){
depth.vec[i] = ProjQuantileDepth(Colon$X[-i,], Colon$X[i,], 10,0.5,0.2,0.1)
}
depth.vec
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(Colon$X[-i,], Colon$X[i,], .5)
}
depth.vec
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(Colon$X, Colon$X[i,], .5)
}
depth.vec
max(depth.vec)
sourceCpp("ProjQuantNew.cpp", verbose=TRUE, rebuild=FALSE);
sourceCpp("ProjQuantNew.cpp", verbose=TRUE, rebuild=FALSE);
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(Colon$X, Colon$X[i,], .5)
}
depth.vec
sourceCpp("ProjQuantNew.cpp", verbose=TRUE, rebuild=FALSE);
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(Colon$X, Colon$X[i,], .5)
}
depth.vec
sourceCpp("ProjQuantNew.cpp", verbose=TRUE, rebuild=FALSE);
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(Colon$X, Colon$X[i,], .5)
}
depth.vec
?Colon
cols = ifelse(Colon$Y==2, "red","green")
plot(log(depth.vec)~1:n, col=cols)
plot(log(depth.vec), col=cols)
?t.test
t.test(depth.vec, Colon$Y)
t.test(Colon$Y~depth.vec)
t.test(depth.vec[which(Colon$Y==1)], depth.vec[which(Colon$Y==2)])
ks.test(depth.vec[which(Colon$Y==1)], depth.vec[which(Colon$Y==2)])
for(i in 1:n){
depth.vec[i] = ProjQuantileDepth(Colon$X, Colon$X[i,], .5, 10,0.5,0.2,0.1)
}
depth.vec
cols = ifelse(Colon$Y==2, "red","green")
plot(log(depth.vec), col=cols)
t.test(depth.vec[which(Colon$Y==1)], depth.vec[which(Colon$Y==2)])
ks.test(depth.vec[which(Colon$Y==1)], depth.vec[which(Colon$Y==2)])
depth.vec1 = rep(0,n)
for(i in 1:n){
depth.vec1[i] = ProjQuantileDepth(Colon$X, Colon$X[i,], 10,0.5,0.2,0.1)
}
depth.vec1
cols = ifelse(Colon$Y==2, "red","green")
plot(log(depth.vec1), col=cols)
t.test(depth.vec1[which(Colon$Y==1)], depth.vec1[which(Colon$Y==2)])
ks.test(depth.vec1[which(Colon$Y==1)], depth.vec1[which(Colon$Y==2)])
depth.vec1 = rep(0,n)
for(i in 1:n){
depth.vec1[i] = -log(ProjQuantileDepth(Colon$X, Colon$X[i,], 10,0.5,0.2,0.1))
}
depth.vec1
sourceCpp("ProjQuantNew.cpp", verbose=TRUE, rebuild=FALSE);
depth.vec1 = rep(0,n)
for(i in 1:n){
depth.vec1[i] = -log(ProjQuantileDepth(Colon$X, Colon$X[i,], 10,0.5,0.2,0.1))
}
depth.vec1
cols = ifelse(Colon$Y==2, "red","green")
plot(log(depth.vec1), col=cols)
t.test(depth.vec1[which(Colon$Y==1)], depth.vec1[which(Colon$Y==2)])
ks.test(depth.vec1[which(Colon$Y==1)], depth.vec1[which(Colon$Y==2)])
depth.vec = rep(0,n)
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(Colon$X, Colon$X[i,], .5)
}
depth.vec
cols = ifelse(Colon$Y==2, "red","green")
plot(log(depth.vec), col=cols)
t.test(depth.vec[which(Colon$Y==1)], depth.vec[which(Colon$Y==2)])
ks.test(depth.vec[which(Colon$Y==1)], depth.vec[which(Colon$Y==2)])
cols = ifelse(Colon$Y==2, "red","green")
plot(log(depth.vec1), col=cols)
plot(depth.vec1, col=cols)
t.test(depth.vec1[which(Colon$Y==1)], depth.vec1[which(Colon$Y==2)])
ks.test(depth.vec1[which(Colon$Y==1)], depth.vec1[which(Colon$Y==2)])
depth.vec1 = rep(0,n)
for(i in 1:n){
depth.vec1[i] = -log(ProjQuantileDepth(Colon$X, Colon$X[i,], 10,0.5,0.2,0.1))
}
depth.vec1
cols = ifelse(Colon$Y==2, "red","green")
plot(depth.vec1, col=cols)
t.test(depth.vec1[which(Colon$Y==1)], depth.vec1[which(Colon$Y==2)])
ks.test(depth.vec1[which(Colon$Y==1)], depth.vec1[which(Colon$Y==2)])
require(FastHCS)
data(DnaAlteration)
dim(DnaAlteration)
names(DnaAlteration)
n = dim(DnaAlteration)[1]
depth.vec = rep(0,n)
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(DnaAlteration[-i,-1], DnaAlteration[i,-1], .5)
}
class(Colon$X)
DnaAlt.x = as.matrix(DnaAlteration[,-1])
DnaAlt.y = as.matrix(DnaAlteration[,1])
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(DnaAlt.x[-i,],DnaAlt.x[i,], .5)
}
depth.vec
cols = ifelse(Colon$Y==2, "red","green")
plot(log(depth.vec), col=cols)
t.test(depth.vec[which(Colon$Y==1)], depth.vec[which(Colon$Y==2)])
ks.test(depth.vec[which(Colon$Y==1)], depth.vec[which(Colon$Y==2)])
t.test(depth.vec[which(DnaAlt.y==1)], depth.vec[which(DnaAlt.y==2)])
depth.vec
cols = ifelse(DnaAlt.y==2, "red","green")
DnaAlt.y
cols = ifelse(DnaAlt.y==1, "red","green")
plot(log(depth.vec), col=cols)
t.test(depth.vec[which(DnaAlt.y==1)], depth.vec[which(DnaAlt.y==2)])
t.test(depth.vec[which(DnaAlt.y==1)], depth.vec[which(DnaAlt.y==0)])
ks.test(depth.vec[which(DnaAlt.y==1)], depth.vec[which(DnaAlt.y==0)])
n = dim(DnaAlteration)[1]
depth.vec = rep(0,n)
DnaAlt.x = as.matrix(DnaAlteration[,-1])
DnaAlt.y = as.matrix(DnaAlteration[,1])
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(DnaAlt.x[-i,],DnaAlt.x[i,], .2)
}
depth.vec
cols = ifelse(DnaAlt.y==1, "red","green")
plot(log(depth.vec), col=cols)
t.test(depth.vec[which(DnaAlt.y==1)], depth.vec[which(DnaAlt.y==0)])
ks.test(depth.vec[which(DnaAlt.y==1)], depth.vec[which(DnaAlt.y==0)])
n = dim(DnaAlteration)[1]
depth.vec = rep(0,n)
DnaAlt.x = as.matrix(DnaAlteration[,-1])
DnaAlt.y = as.matrix(DnaAlteration[,1])
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(DnaAlt.x[-i,],DnaAlt.x[i,], .1)
}
depth.vec
cols = ifelse(DnaAlt.y==1, "red","green")
plot(log(depth.vec), col=cols)
t.test(depth.vec[which(DnaAlt.y==1)], depth.vec[which(DnaAlt.y==0)])
ks.test(depth.vec[which(DnaAlt.y==1)], depth.vec[which(DnaAlt.y==0)])
plot(depth.vec, col=cols)
n = dim(DnaAlteration)[1]
depth.vec = rep(0,n)
DnaAlt.x = as.matrix(DnaAlteration[,-1])
DnaAlt.y = as.matrix(DnaAlteration[,1])
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(DnaAlt.x[-i,],DnaAlt.x[i,], 1)
}
depth.vec
cols = ifelse(DnaAlt.y==1, "red","green")
plot(depth.vec, col=cols)
depth.vec = rep(0,n)
DnaAlt.x = as.matrix(DnaAlteration[,-1])
DnaAlt.y = as.matrix(DnaAlteration[,1])
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(DnaAlt.x[-i,],DnaAlt.x[i,], .99)
}
depth.vec
cols = ifelse(DnaAlt.y==1, "red","green")
plot(depth.vec, col=cols)
t.test(depth.vec[which(DnaAlt.y==1)], depth.vec[which(DnaAlt.y==0)])
ks.test(depth.vec[which(DnaAlt.y==1)], depth.vec[which(DnaAlt.y==0)])
n = dim(DnaAlteration)[1]
depth.vec = rep(0,n)
DnaAlt.x = as.matrix(DnaAlteration[,-1])
DnaAlt.y = as.matrix(DnaAlteration[,1])
for(i in 1:n){
depth.vec[i] = ProjQuantileDepthMod(DnaAlt.x[-i,],DnaAlt.x[i,], .999)
}
depth.vec
cols = ifelse(DnaAlt.y==1, "red","green")
plot(depth.vec, col=cols)

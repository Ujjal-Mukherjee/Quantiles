## function to compute outlier score
outlier.score = function(X, type, k=NULL){
n = nrow(X)
if(is.null(k)){
k = floor(.1*n)
}
depth.vec = rep(0,n)
knn.vec = rep(0,n)
# calculate distance matrix for full data
dist.mat = as.matrix(dist(X))
# get depth and knn average dist for all data
for(i in 1:n){
if(type==1){
depth.vec[i] = ProjQuantileDepthMod(X[-i,], X[i,], .5)
}
else{
depth.vec[i] = EPQD(X[-i,], X[i,])
}
ik = order(dist.mat[i,])[2:(k+1)]
knn.vec[i] = mean(dist.mat[i,ik])
}
return(log(knn.vec/depth.vec))
}
sourceCpp("ProjQuantNew.cpp", verbose=TRUE, rebuild=FALSE);
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(rnorm(50)+10, ncol=2)
label.vec = c(rep("1",475), rep("2", 25))
X = rbind(X1,X2)
score.vec = outlier.score(X, type=1) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=2)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
set.seed(11182014)
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(rnorm(50)+10, ncol=2)
label.vec = c(rep("1",475), rep("2", 25))
X = rbind(X1,X2)
score.vec = outlier.score(X, type=2) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=2)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(runif(50, -1, 1), ncol=2)
normX2 = sqrt(X2[,1]^2+X2[,2]^2)
X2 = X2/normX2*10
label.vec = c(rep("1",475), rep("2", 25))
X = rbind(X1,X2)
score.vec = outlier.score(X, type=1) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=2)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
sourceCpp("ProjQuantNew.cpp", verbose=TRUE, rebuild=FALSE);
set.seed(11182014)
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(rnorm(50)+10, ncol=2)
label.vec = c(rep("1",475), rep("2", 25))
X = rbind(X1,X2)
score.vec = outlier.score(X, type=2) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=2)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=1)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
score.vec = outlier.score(X, type=1) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=1)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
plot(density(score.vec))
outlier.score = function(X, type, k=NULL){
n = nrow(X)
if(is.null(k)){
k = floor(.1*n)
}
depth.vec = rep(0,n)
knn.vec = rep(0,n)
# calculate distance matrix for full data
dist.mat = as.matrix(dist(X))
# get depth and knn average dist for all data
for(i in 1:n){
if(type==1){
depth.vec[i] = ProjQuantileDepthMod(X[-i,], X[i,], .5)
}
else{
depth.vec[i] = EPQD(X[-i,], X[i,])
}
ik = order(dist.mat[i,])[2:(k+1)]
knn.vec[i] = mean(dist.mat[i,ik])
}
return(log(knn.vec/depth.vec))
}
set.seed(11182014)
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(rnorm(50)+10, ncol=2)
label.vec = c(rep("1",475), rep("2", 25))
X = rbind(X1,X2)
score.vec = outlier.score(X, type=1) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=1)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(runif(50, -1, 1), ncol=2)
normX2 = sqrt(X2[,1]^2+X2[,2]^2)
X2 = X2/normX2*10
label.vec = c(rep("1",475), rep("2", 25))
X = rbind(X1,X2)
score.vec = outlier.score(X, type=1) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=2)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
require(cepp)
data(Colon)
n = length(Colon$Y)
score.vec = outlier.score(Colon$X, type=1)
cols = ifelse(Colon$Y==2, "red","green")
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
abline(h=quantile(score.vec,.1), lty=2, lwd=2)
score.vec
require(FastHCS)
data(DnaAlteration)
n = dim(DnaAlteration)[1]
depth.vec = rep(0,n)
DnaAlt.x = as.matrix(DnaAlteration[,-1])
DnaAlt.y = as.matrix(DnaAlteration[,1])
score.vec = outlier.score(DnaAlt.x, type=1)
cols = ifelse(DnaAlt.y==1, "red","green")
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
abline(h=quantile(score.vec,.1), lty=2, lwd=2)
require(FastHCS)
data(DnaAlteration)
n = dim(DnaAlteration)[1]
depth.vec = rep(0,n)
DnaAlt.x = as.matrix(DnaAlteration[,-1])
DnaAlt.y = as.matrix(DnaAlteration[,1])
score.vec = outlier.score(DnaAlt.x, type=2)
cols = ifelse(DnaAlt.y==1, "red","green")
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
abline(h=quantile(score.vec,.1), lty=2, lwd=2)
par(mfrow=c(2,2))
plot(lm(stack.loss~., data=stackloss))
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(stackloss[,-4]), type=2)
plot(score.vec, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(stackloss[,-4]), type=1)
plot(score.vec, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
require(robustbase)
score.vec = outlier.score(as.matrix(hbk[,-4]), type=2, k=10)
plot(score.vec, pch=19, cex=.5)
#abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(hbk[,-4]), type=1, k=10)
plot(score.vec, pch=19, cex=.5)
score.vec = outlier.score(as.matrix(hbk[,-4]), type=1)
plot(score.vec, pch=19, cex=.5)
plot(density(score.vec))
Animals1 = within(Animals, {lbodywt=log(body)
lbrainwt=log(brain)})
score.vec = outlier.score(as.matrix(Animals1[,1:2]), type=2)
par(mfrow=c(1,2))
with(Animals1, plot(body, brain, col="white"))
with(Animals1, text(body, brain, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
Animals1 = within(Animals, {lbodywt=log(body)
lbrainwt=log(brain)})
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=1)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
outlier.score = function(X, type, k=NULL, alpha){
n = nrow(X)
if(is.null(k)){
k = floor(.1*n)
}
depth.vec = rep(0,n)
knn.vec = rep(0,n)
# calculate distance matrix for full data
dist.mat = as.matrix(dist(X))
# get depth and knn average dist for all data
for(i in 1:n){
if(type==1){
depth.vec[i] = ProjQuantileDepthMod(X[-i,], X[i,], .5)
}
else{
depth.vec[i] = EPQD(X[-i,], X[i,])
}
ik = order(dist.mat[i,])[2:(k+1)]
knn.vec[i] = mean(dist.mat[i,ik])
}
lknn = log(knn.vec)
lhtped = -log(depth.vec)
return(alpha*lknn + (1-alpha)*lhtped)
}
set.seed(11182014)
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(rnorm(50)+10, ncol=2)
label.vec = c(rep("1",475), rep("2", 25))
X = rbind(X1,X2)
score.vec = outlier.score(X, type=1, alpha=.5) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=1)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
score.vec = outlier.score(X, type=1, alpha=.2) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=1)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
score.vec = outlier.score(X, type=1, alpha=.01) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=1)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
score.vec = outlier.score(X, type=1, alpha=.99) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=1)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
score.vec = outlier.score(X, type=1, alpha=.99, k=5) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=1)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
score.vec = outlier.score(X, type=1, alpha=.5) # type 1 = ray depth, type 2 = PQD
cols = c(rep("red",475), rep("green", 25))
par(mfrow=c(1,2))
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.95), lty=2, lwd=1)
#abline(h=quantile(score.vec,.05), lty=2, lwd=2)
q9 = quantile(score.vec,.95)
col.vec = ifelse(score.vec>q9, "darkred", "darkgreen")
plot(X, pch=label.vec, col=col.vec)
par(mfrow=c(1,1))
score.vec = outlier.score(Colon$X, type=1, alpha=.5)
score.vec
require(FastHCS)
data(DnaAlteration)
n = dim(DnaAlteration)[1]
depth.vec = rep(0,n)
DnaAlt.x = as.matrix(DnaAlteration[,-1])
DnaAlt.y = as.matrix(DnaAlteration[,1])
score.vec = outlier.score(DnaAlt.x, type=1, alpha=.5)
cols = ifelse(DnaAlt.y==1, "red","green")
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
abline(h=quantile(score.vec,.1), lty=2, lwd=2)
cols = ifelse(DnaAlt.y==1, "red","green")
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
plot(density(score.vec))
score.vec = outlier.score(as.matrix(stackloss[,-4]), type=1)
plot(score.vec, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(stackloss[,-4]),
type=1, alpha=.5)
plot(score.vec, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(stackloss[,-4]),
type=1, alpha=.2)
plot(score.vec, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(stackloss[,-4]),
type=1, alpha=.8)
plot(score.vec, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(hbk[,-4]),
type=1, alpha=.5)
plot(score.vec, pch=19, cex=.5)
score.vec = outlier.score(as.matrix(hbk[,-4]),
type=1, alpha=.2)
plot(score.vec, pch=19, cex=.5)
eigen(matrix(1,0,0,0,0,1,0,1,0), ncol=3)
eigen(matrix(c(1,0,0,0,0,1,0,1,0), ncol=3))
library(faraway)
summary(UCBAdmissions)
apply(chisq.test, 3, UCBAdmissions)
apply(UCBAdmissions, 3, chisq.test)
sample(1:10, 5)
n = 100; p = 50
v.star = 1
beta.star = c(sample(1:10, 10, replace=T), rep(0,40)
Sigma = diag(p)
X = my.mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
y = my.mvrnorm(n=1, mu=rep(0,100)+X%*%beta.star, Sigma=v.star*diag(100))
rm(list=ls())
set.seed(10212014)
## Function to generate multivariate normal observations
my.mvrnorm = function(n, mu, Sigma){
p = length(mu)
# compute square root of covariance matrix
eo=eigen(Sigma, symmetric=TRUE)
sigma.sqrt=eo$vec%*%diag(eo$val^0.5)%*%t(eo$vec)
# generate random normals from runif by box-muller transform
rnorm.vec = sqrt(-2*log(runif(n*p)))*cos(2*pi*runif(n*p))
# generate sample matrix
sample.matrix = matrix(rep(mu, n), nrow=n, byrow=T) +
matrix(rnorm.vec, nrow=n, ncol=p)%*%sigma.sqrt
return(sample.matrix)
}
## simulation setup
n = 100; p = 50
v.star = 1
beta.star = c(sample(1:10, 10, replace=T), rep(0,40)
Sigma = diag(p)
X = my.mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
y = my.mvrnorm(n=1, mu=rep(0,100)+X%*%beta.star, Sigma=v.star*diag(100))
beta.star = c(sample(1:10, 10, replace=T), rep(0,40))
Sigma = diag(p)
X = my.mvrnorm(n=n, mu=rep(0,p), Sigma=Sigma)
y = my.mvrnorm(n=1, mu=rep(0,100)+X%*%beta.star, Sigma=v.star*diag(100))
dim(X)
dim(y)
library(glmnet)
mod1 = glmnet(X,y)
plot(mod1)
names(mod1)
View(mod1$beta)
mod1$beta
names(mod1)
dim(mod1$beta)
length(mod1$lambda)
mod1$lambda
mod1$beta[,1]
mod1$beta[,2]
mod1$beta[,12]
View(as.matrix(mod1$beta))
sumcoefs = apply(abs(beta), 1, sum)
beta = as.matrix(mod1$beta)
sumcoefs = apply(abs(beta), 1, sum)
sumcoefs
sumcoefs = apply(abs(beta), 2, sum)
sumcoefs
lambda.fnzero = mod1$lambda[min(which(sumcoefs>0))]
lambda.fnzero
py = sample(y, n, replace=F)
py
lambda.fnzero(glmnet.model){
beta = as.matrix(glmnet.model$beta)
sumcoefs = apply(abs(beta), 2, sum)
glmnet.model$lambda[min(which(sumcoefs>0))]
}
lambda.fnzero = function(glmnet.model){
beta = as.matrix(glmnet.model$beta)
sumcoefs = apply(abs(beta), 2, sum)
glmnet.model$lambda[min(which(sumcoefs>0))]
}
true.lam = lambda.fnzero(mod1)
(true.lam = lambda.fnzero(mod1))
nperm = 1000
lam.vec = rep(0, nperm)
for i=1:nperm{
iy = sample(y, n, replace=F)
imod1 = glmnet(X, iy)
lam.vec[i] = lambda.fnzero(imod1)
}
for(i=1:nperm){
iy = sample(y, n, replace=F)
imod1 = glmnet(X, iy)
lam.vec[i] = lambda.fnzero(imod1)
}
for(i in 1:nperm){
iy = sample(y, n, replace=F)
imod1 = glmnet(X, iy)
lam.vec[i] = lambda.fnzero(imod1)
}
hist(lam.vec)
sum(true.lam>lam.vec)/nperm
(pval = sum(true.lam<lam.vec)/nperm)
abline(v=true.lam, pwd=2, col="Red")
abline(v=true.lam, lwd=2, col="Red")
hist(lam.vec)
abline(v=true.lam, lwd=2, col="Red")
hist(lam.vec)
abline(v=true.lam, lwd=2, col="Red")
hist(lam.vec, xlim=c(0,max(lam.vec, true.lam)))
abline(v=true.lam, lwd=2, col="Red")
dim(beta)
lambda.fnzero = function(glmnet.model, index=NULL){
if(is.null(index)){
beta = as.matrix(glmnet.model$beta)
}
else{
beta = as.matrix(glmnet.model$beta[index,])
}
sumcoefs = apply(abs(beta), 2, sum)
glmnet.model$lambda[min(which(sumcoefs>0))]
}
View(beta)
index.vec = 11:15
mod1 = glmnet(X,y)
(true.lam = lambda.fnzero(mod1, index=index.vec))
# consider permutations
nperm = 1000
lam.vec = rep(0, nperm)
for(i in 1:nperm){
iy = sample(y, n, replace=F)
imod1 = glmnet(X, iy)
lam.vec[i] = lambda.fnzero(imod1, index=index.vec)
}
hist(lam.vec, xlim=c(0,max(lam.vec, true.lam)))
abline(v=true.lam, lwd=2, col="Red")
(pval = sum(true.lam<lam.vec)/nperm)
index.vec = 5:15
mod1 = glmnet(X,y)
(true.lam = lambda.fnzero(mod1, index=index.vec))
# consider permutations
nperm = 1000
lam.vec = rep(0, nperm)
for(i in 1:nperm){
iy = sample(y, n, replace=F)
imod1 = glmnet(X, iy)
lam.vec[i] = lambda.fnzero(imod1, index=index.vec)
}
hist(lam.vec, xlim=c(0,max(lam.vec, true.lam)))
abline(v=true.lam, lwd=2, col="Red")
(pval = sum(true.lam<lam.vec)/nperm)
index.vec = 11:30
mod1 = glmnet(X,y)
(true.lam = lambda.fnzero(mod1, index=index.vec))
# consider permutations
nperm = 1000
lam.vec = rep(0, nperm)
for(i in 1:nperm){
iy = sample(y, n, replace=F)
imod1 = glmnet(X, iy)
lam.vec[i] = lambda.fnzero(imod1, index=index.vec)
}
hist(lam.vec, xlim=c(0,max(lam.vec, true.lam)))
abline(v=true.lam, lwd=2, col="Red")
(pval = sum(true.lam<lam.vec)/nperm)

}
p=optimize(f=DepVec, interval=c(0.05,0.3), d=d, u=u)
z=1:5
length(which(z==0))
wEPQD(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# make grid of points
pts = seq(mingrid,maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
xygrid = xygrid[-which0,]
}
rm(xcoord,ycoord)
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=1000)
normsq.X = apply(X^2,1,sum)
normsq.grid = apply(xygrid^2,1,sum)
# loop over 1000 pts on unit circle then take max
for(iu in 1:1000){
u = rnorm(2); u = u/sqrt(sum(u^2))
Xu = X%*%u
Xuperp = sqrt(normsq.X - Xu^2)
mu.Xuperp = mean(Xuperp)
w = dnorm(Xuperp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w*Xu)
xygrid.u = xygrid%*%u
wu = dnorm(sqrt(normsq.grid - xygrid.u^2), sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu*xygrid.u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
}
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# make grid of points
pts = seq(mingrid,maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
xygrid = xygrid[-which0,]
}
rm(xcoord,ycoord)
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=1000)
normsq.X = apply(X^2,1,sum)
normsq.grid = apply(xygrid^2,1,sum)
# loop over 1000 pts on unit circle then take max
for(iu in 1:1000){
u = rnorm(2); u = u/sqrt(sum(u^2))
Xu = X%*%u
Xuperp = sqrt(normsq.X - Xu^2)
mu.Xuperp = mean(Xuperp)
w = dnorm(Xuperp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w*Xu)
xygrid.u = xygrid%*%u
wu = dnorm(sqrt(normsq.grid - xygrid.u^2), sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu*xygrid.u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
}
wEPQD(X, sig=1)
wEPQD(X, sig=1, mingrid=-11, maxgrid=-1)
wEPQD(d, sig=1, mingrid=-5, maxgrid=5)
wEPQD(d, sig=.1, mingrid=-5, maxgrid=5)
wEPQD(d, sig=.2, mingrid=-5, maxgrid=5)
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# make grid of points
pts = seq(mingrid,maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
xygrid = xygrid[-which0,]
}
rm(xcoord,ycoord)
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
normsq.X = apply(X^2,1,sum)
normsq.grid = apply(xygrid^2,1,sum)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = rnorm(2); u = u/sqrt(sum(u^2))
Xu = X%*%u
Xuperp = sqrt(normsq.X - Xu^2)
mu.Xuperp = mean(Xuperp)
w = dnorm(Xuperp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w*Xu)
xygrid.u = xygrid%*%u
wu = dnorm(sqrt(normsq.grid - xygrid.u^2), sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu*xygrid.u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
}
wEPQD(d, sig=.2, mingrid=-5, maxgrid=5)
wEPQD(X, sig=.2, mingrid=-5, maxgrid=5)
wEPQD(X, sig=.2, mingrid=-11, maxgrid=-1)
wEPQD(X, sig=1, mingrid=-11, maxgrid=-1)
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# make grid of points
pts = seq(mingrid,maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
xygrid = xygrid[-which0,]
}
rm(xcoord,ycoord)
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
normsq.X = apply(X^2,1,sum)
normsq.grid = apply(xygrid^2,1,sum)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = rnorm(2); u = u/sqrt(sum(u^2))
Xu = X%*%u
Xuperp = sqrt(normsq.X - Xu^2)
mu.Xuperp = mean(Xuperp)
w = dnorm(Xuperp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w*Xu)
xygrid.u = xygrid%*%u
wu = dnorm(sqrt(normsq.grid - xygrid.u^2), sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu*xygrid.u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
return(Fuxu.mat)
}
k = wEPQD(X, sig=1, mingrid=-11, maxgrid=-1)
View(k)
k = wEPQD(d, sig=1, mingrid=-3, maxgrid=3)
View(k)
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# make grid of points
pts = seq(mingrid,maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
xygrid = xygrid[-which0,]
}
rm(xcoord,ycoord)
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
normsq.X = apply(X^2,1,sum)
normsq.grid = apply(xygrid^2,1,sum)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = rnorm(2); u = u/sqrt(sum(u^2))
Xu = X%*%u
Xuperp = sqrt(normsq.X - Xu^2)
mu.Xuperp = mean(Xuperp)
w = dnorm(Xuperp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w*Xu)
xygrid.u = xygrid%*%u
wu = dnorm(sqrt(normsq.grid - xygrid.u^2), sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu*xygrid.u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
return(EPQD.vec)
}
k = wEPQD(d, sig=1, mingrid=-3, maxgrid=3)
View(k)
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# make grid of points
pts = seq(mingrid,maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
rm(xcoord,ycoord)
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
normsq.X = apply(X^2,1,sum)
normsq.grid = apply(xygrid^2,1,sum)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = rnorm(2); u = u/sqrt(sum(u^2))
Xu = X%*%u
Xuperp = sqrt(normsq.X - Xu^2)
mu.Xuperp = mean(Xuperp)
w = dnorm(Xuperp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w*Xu)
xygrid.u = xygrid%*%u
wu = dnorm(sqrt(normsq.grid - xygrid.u^2), sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu*xygrid.u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
# check if contains origin... if so, assign NA to that depth
xygrid = cbind(xcoord,ycoord)
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
EPQD.vec[which0] = NA
}
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
return(EPQD.vec)
}
k = wEPQD(d, sig=1, mingrid=-3, maxgrid=3)
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# make grid of points
pts = seq(mingrid, maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(Xcoord, ycoord)
rm(xcoord,ycoord)
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
normsq.X = apply(X^2,1,sum)
normsq.grid = apply(xygrid^2,1,sum)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = rnorm(2); u = u/sqrt(sum(u^2))
Xu = X%*%u
Xuperp = sqrt(normsq.X - Xu^2)
mu.Xuperp = mean(Xuperp)
w = dnorm(Xuperp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w*Xu)
xygrid.u = xygrid%*%u
wu = dnorm(sqrt(normsq.grid - xygrid.u^2), sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu*xygrid.u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
# check if contains origin... if so, assign NA to that depth
xygrid = cbind(xcoord,ycoord)
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
EPQD.vec[which0] = NA
}
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
return(EPQD.vec)
}
## Empirically calculate PQD with grid search
# Bivariate normal mixture
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(-8,-8), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(-10,-4), Sigma=sig)
X = rbind(X1,X2)
k = wEPQD(d, sig=1, mingrid=-3, maxgrid=3)
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# make grid of points
pts = seq(mingrid, maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord, ycoord)
rm(xcoord,ycoord)
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
normsq.X = apply(X^2,1,sum)
normsq.grid = apply(xygrid^2,1,sum)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = rnorm(2); u = u/sqrt(sum(u^2))
Xu = X%*%u
Xuperp = sqrt(normsq.X - Xu^2)
mu.Xuperp = mean(Xuperp)
w = dnorm(Xuperp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w*Xu)
xygrid.u = xygrid%*%u
wu = dnorm(sqrt(normsq.grid - xygrid.u^2), sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu*xygrid.u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
# check if contains origin... if so, assign NA to that depth
xygrid = cbind(xcoord,ycoord)
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
EPQD.vec[which0] = NA
}
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
return(EPQD.vec)
}
## Empirically calculate PQD with grid search
# Bivariate normal mixture
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(-8,-8), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(-10,-4), Sigma=sig)
X = rbind(X1,X2)
k = wEPQD(d, sig=1, mingrid=-3, maxgrid=3)
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# make grid of points
pts = seq(mingrid, maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
normsq.X = apply(X^2,1,sum)
normsq.grid = apply(xygrid^2,1,sum)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = rnorm(2); u = u/sqrt(sum(u^2))
Xu = X%*%u
Xuperp = sqrt(normsq.X - Xu^2)
mu.Xuperp = mean(Xuperp)
w = dnorm(Xuperp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w*Xu)
xygrid.u = xygrid%*%u
wu = dnorm(sqrt(normsq.grid - xygrid.u^2), sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu*xygrid.u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
# check if contains origin... if so, assign NA to that depth
xygrid = cbind(xcoord,ycoord)
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
EPQD.vec[which0] = NA
}
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
return(EPQD.vec)
}
## Empirically calculate PQD with grid search
# Bivariate normal mixture
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(-8,-8), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(-10,-4), Sigma=sig)
X = rbind(X1,X2)
d<-apply(X,2,FUN=function(x){return((x-mean(x))/max(x))});
z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
plot(d)
lines(z)
k = wEPQD(d, sig=1, mingrid=-3, maxgrid=3)
k = wEPQD(X, sig=1, mingrid=-3, maxgrid=3)
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# make grid of points
pts = seq(mingrid, maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
normsq.X = apply(X^2,1,sum)
normsq.grid = apply(xygrid^2,1,sum)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = rnorm(2); u = u/sqrt(sum(u^2))
Xu = X%*%u
Xuperp = sqrt(normsq.X - Xu^2)
mu.Xuperp = mean(Xuperp)
w = dnorm(Xuperp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w*Xu)
xygrid.u = xygrid%*%u
wu = dnorm(sqrt(normsq.grid - xygrid.u^2), sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu*xygrid.u)
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
# check if contains origin... if so, assign NA to that depth
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
EPQD.vec[which0] = NA
}
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
return(EPQD.vec)
}
k = wEPQD(X, sig=1, mingrid=-3, maxgrid=3)
k = wEPQD(d, sig=1, mingrid=-3, maxgrid=3)
View(k)
k = wEPQD(X, sig=1, mingrid=-11, maxgrid=-3)
k = wEPQD(X, sig=1, mingrid=-15, maxgrid=-3)

plot(score.vec, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(hbk[,-4]), type=2, k=5)
plot(score.vec, pch=19, cex=.5)
score.vec = outlier.score(as.matrix(hbk[,-4]), type=2, k=10)
plot(score.vec, pch=19, cex=.5)
score.vec = outlier.score(as.matrix(hbk[,-4]), type=2, k=75)
plot(score.vec, pch=19, cex=.5)
outlier.score = function(X, type, k=NULL){
n = nrow(X)
if(is.null(k)){
k = floor(.1*n)
}
depth.vec = rep(0,n)
knn.vec = rep(0,n)
# calculate distance matrix for full data
dist.mat = as.matrix(dist(X))
# get depth and knn average dist for all data
for(i in 1:n){
if(type==1){
depth.vec[i] = ProjQuantileDepthMod(X[-i,], X[i,], .5)
}
else{
depth.vec[i] = EPQD(X[-i,], X[i,])
}
ik = order(dist.mat[i,])[1:k]
knn.vec[i] = mean(dist.mat[i,ik])
}
return(log(knn.vec^10/depth.vec))
}
score.vec = outlier.score(as.matrix(hbk[,-4]), type=2)
plot(score.vec, pch=19, cex=.5)
outlier.score = function(X, type, k=NULL){
n = nrow(X)
if(is.null(k)){
k = floor(.1*n)
}
depth.vec = rep(0,n)
knn.vec = rep(0,n)
# calculate distance matrix for full data
dist.mat = as.matrix(dist(X))
# get depth and knn average dist for all data
for(i in 1:n){
if(type==1){
depth.vec[i] = ProjQuantileDepthMod(X[-i,], X[i,], .5)
}
else{
depth.vec[i] = EPQD(X[-i,], X[i,])
}
ik = order(dist.mat[i,])[1:k]
knn.vec[i] = mean(dist.mat[i,ik])
}
return(log(knn.vec/depth.vec))
}
score.vec = outlier.score(as.matrix(hbk[,-4]), type=2)
plot(score.vec, pch=19, cex=.5)
Animals
with(Animals, plot(log(body), log(brain)))
labels = paste(1:21)
with(Animals, plot(log(body), log(brain), pch=labels))
labels
with(Animals, plot(log(body), log(brain), pch=Animals[,1]))
with(Animals, plot(log(body), log(brain), pch=paste(labels)))
Animals1 = within(Animals, {lbodywt=log(body)
lbrainwt=log(brain)})
Animals1
score.vec = outlier.score(as.matrix(Animals1[,-1:2]), type=2)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2)
plot(score.vec, pch=19, cex=.5)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=1)
plot(score.vec, pch=19, cex=.5)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2)
plot(score.vec, pch=19, cex=.5)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=5)
plot(score.vec, pch=19, cex=.5)
row.names(Animals)
plot(score.vec, pch=row.names(Animals1), cex=.5)
plot(score.vec, pch=1:28, cex=.5)
plot(score.vec, pch=paste(1:28), cex=.5)
plot(score.vec, pch=paste(21), cex=.5)
plot(score.vec)
text(score.vec, paste(1:28), cex=.5)
plot(score.vec, col="white")
text(score.vec, paste(1:28), cex=.5)
text(score.vec, paste(1:28))
plot(score.vec, col="white")
text(score.vec, paste(1:28))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=10)
plot(score.vec, col="white")
text(score.vec, paste(1:28))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
text(score.vec, row.names(Animals))
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=10)
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=20)
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=1)
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=2)
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=25)
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=1, k=25)
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
with(Animals, plot(log(body), log(brain)))
with(Animals, text(log(body), log(brain). row.names(Animals)))
with(Animals, plot(log(body), log(brain)))
with(Animals, text(log(body), log(brain), row.names(Animals)))
with(Animals1, plot(lbodywt, lbrainwt))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals)))
with(Animals1, plot(lbodywt, lbrainwt), col="white")
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals)))
with(Animals1, plot(lbodywt, lbrainwt))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals)))
z=dist(Animals)
z
z=dist(Animals1[,3:4])
z
z=as.matrix(z)
View(z)
order(z[1,])
order(z[1,])[1:5]
z[1,order(z[1,])[1:5]]
outlier.score = function(X, type, k=NULL){
n = nrow(X)
if(is.null(k)){
k = floor(.1*n)
}
depth.vec = rep(0,n)
knn.vec = rep(0,n)
# calculate distance matrix for full data
dist.mat = as.matrix(dist(X))
# get depth and knn average dist for all data
for(i in 1:n){
if(type==1){
depth.vec[i] = ProjQuantileDepthMod(X[-i,], X[i,], .5)
}
else{
depth.vec[i] = EPQD(X[-i,], X[i,])
}
ik = order(dist.mat[i,])[2:(k+1)]
knn.vec[i] = mean(dist.mat[i,ik])
}
return(log(knn.vec/depth.vec))
}
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=1, k=25)
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=25)
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=5)
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2)
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals)))
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals)))
plot(score.vec, col="white")
text(score.vec, row.names(Animals))
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
require(robustbase)
score.vec = outlier.score(as.matrix(hbk[,-4]), type=2)
plot(score.vec, pch=19, cex=.5)
score.vec = outlier.score(as.matrix(hbk[,-4]), type=2, k=10)
plot(score.vec, pch=19, cex=.5)
outlier.score = function(X, type, k=NULL){
n = nrow(X)
if(is.null(k)){
k = floor(.1*n)
}
depth.vec = rep(0,n)
knn.vec = rep(0,n)
# calculate distance matrix for full data
dist.mat = as.matrix(dist(X))
# get depth and knn average dist for all data
for(i in 1:n){
if(type==1){
depth.vec[i] = ProjQuantileDepthMod(X[-i,], X[i,], .5)
}
else{
depth.vec[i] = EPQD(X[-i,], X[i,])
}
ik = order(dist.mat[i,])[2:(k+1)]
knn.vec[i] = median(dist.mat[i,ik])
}
return(log(knn.vec/depth.vec))
}
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
outlier.score = function(X, type, k=NULL){
n = nrow(X)
if(is.null(k)){
k = floor(.1*n)
}
depth.vec = rep(0,n)
knn.vec = rep(0,n)
# calculate distance matrix for full data
dist.mat = as.matrix(dist(X))
# get depth and knn average dist for all data
for(i in 1:n){
if(type==1){
depth.vec[i] = ProjQuantileDepthMod(X[-i,], X[i,], .5)
}
else{
depth.vec[i] = EPQD(X[-i,], X[i,])
}
ik = order(dist.mat[i,])[2:(k+1)]
knn.vec[i] = mean(dist.mat[i,ik])
}
return(log(knn.vec/depth.vec))
}
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=10)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2, k=5)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(Animals1[,3:4]), type=2)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(Animals1[,1:2]), type=2)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(Animals1[,1:2]), type=2, k=5)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(Animals1[,1:2]), type=1)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(Animals1[,1:2]), type=2)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
discoveries
names(discoveries)
discoveries$x
library(faraway)
names(UCBAdmissions)
UCBAdmissions
library(faraway)
y<-c(320,14,80,36)
particle<-gl(2,1,4,labels=c("no","yes")) # gl generates factor levels
quality<-gl(2,2,4,labels=c("good","bad"))
particle
quality
wafer<-data.frame(y,particle,quality)
wafer
80/320    # odds of "bad" without particle
36/14     # odds of "bad" with particle
(36/14)/(80/320)  # odds ratio
bd<-matrix(y,nrow=2)  # the default is byr=F.
bd
fisher.test(bd) # odds ratio is y11*y22/(y12*y21)
fisher.test(bd,alternative = "greater")
data(femsmoke)
femsmoke
ct<-xtabs(y~smoker+dead,femsmoke)
ct
prop.table(ct,1)
summary(ct)  # gives chisquare test of independence
fisher.test(ct)
prop.table(xtabs(y~smoker+age,femsmoke),2) # column sums to 1
xtabs(y~smoker+age,femsmoke)
prop.table(xtabs(y~smoker+age,femsmoke),1) # row sums to 1
xtabs(y~smoker+age,femsmoke)
ct1<-xtabs(y~smoker+dead,femsmoke,subset=(age=="18-24"))
ct1
prop.table(ct1,1)
ct2<-xtabs(y~smoker+dead,femsmoke,subset=(age=="25-34"))
ct2
prop.table(ct2,1)
ct3<-xtabs(y~smoker+dead+age,femsmoke)
ct3
apply(ct3,3,function(x) (x[1,1]*x[2,2]/(x[1,2]*x[2,1]))) # observed odds ratio at the different age groups
ct4<-xtabs(y~smoker+dead,femsmoke,subset=(age=="55-64"))
ct4
prop.table(ct4,1)
m<-glm(ct4~factor(c(0,1)),family=binomial)
summary(m)
drop1(m)
summary(ct4) # Pearson chisquare gives similar result on independence
mantelhaen.test(ct3,exact=TRUE) # test conditional independence in each stratum
summary(ct3) # mutual independence
summary(UCBAdmissions)
class(UCBAdmissions)
UCBAdmissions[,1]
UCBAdmissions[1,,]
UCBAdmissions[1,1,]
UCBAdmissions[,1,]
UCBAdmissions[,,1]
UCBAdmissions[,,2]
UCBAdmissions[,2,]
UCBAdmissions[,3,]
UCBAdmissions[,1,]
UCBAdmissions[1,,]
UCBAdmissions[2,,]
summary(UCBAdmissions)
summary(UCBAdmissions[,,1])
summary(table(UCBAdmissions[,,1]))
chisq.test(table(UCBAdmissions[,,1]))
UCBAdmissions[,,1]
class(UCBAdmissions[,,1])
chisq.test(UCBAdmissions[,,1])
chisq.test(UCBAdmissions[,,2])
chisq.test(UCBAdmissions[,,3])
chisq.test(UCBAdmissions[,,4])
chisq.test(UCBAdmissions[,,5])
score.vec = outlier.score(as.matrix(hbk[,-4]), type=2, k=10)
plot(score.vec, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
Animals1 = within(Animals, {lbodywt=log(body)
lbrainwt=log(brain)})
score.vec = outlier.score(as.matrix(Animals1[,1:2]), type=2)
par(mfrow=c(1,2))
with(Animals1, plot(lbodywt, lbrainwt, col="white"))
with(Animals1, text(lbodywt, lbrainwt, row.names(Animals), cex=.7))
plot(score.vec, col="white")
text(score.vec, row.names(Animals), cex=.7)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
par(mfrow=c(1,1))
with(Animals1, plot(lbodywt, brain, col="white"))
with(Animals1, plot(body, brain, col="white"))
with(Animals1, text(body, brain, row.names(Animals), cex=.7))
dim(UCBAdmissions)
UCBAdmissions[,,1]
UCBAdmissions[,,2]
as.numeric(UCBAdmissions)
Sex = rep(c("M","M","F","F"),6)
Sex
Admitted = rep(c("Y","N"), 12)
Admitted
cbind(nums, Sex, Admitted)
nums = as.numeric(UCBAdmissions)
Sex = rep(c("M","M","F","F"),6)
Admitted = rep(c("Y","N"), 12)
cbind(nums, Sex, Admitted)
Dept = rep(c("A","B","C","D","E","F"), rep(6,4))
Dept = rep(c("A","B","C","D","E","F"), rep(4,6))
Dept
y<-c(360,30,310,390)
n<-c(900,100,450,600)
tr<-c(1,2,1,2) # 1 = 3 mammograms; 2 =  1 mammogram
h<-c(1,1,2,2)  # 1 = With family history; 2 = Without family history
demo<-cbind(Survival=y,Total=n,Treatment=tr,History=h)
xtabs(y~tr,demo)/xtabs(n~tr,demo)
xtabs(y/n~tr+h,demo)
m<-glm(cbind(y,n-y)~tr,family=binomial)
summary(m)
m1<-glm(cbind(y,n-y)~tr+h,family=binomial)
summary(m1) # Missing a lurking variable gives a totally wrong conclusion! The lack of fit is seen from summary(m). But if the history variable is not in the data, no lack of fit can be detected. The new data: y<-c(670,420); n<-c(1350,700); tr<-c(1,2); mm<-glm(cbind(y,n-y)~tr,family=binomial); summary(mm)
m2<-glm(cbind(y,n-y)~tr*h,family=binomial) # no df left.
summary(m2)
nums = matrix(as.numeric(UCBAdmissions), ncol=2, byrow=F)
nums
as.numeric(UCBAdmissions)
nums = matrix(as.numeric(UCBAdmissions), ncol=2, byrow=T)
nums
mod10.pois = glm(nums~Sex*Dept + Admitted*Dept, family=poisson)
nums = as.numeric(UCBAdmissions)
Sex = rep(c("M","M","F","F"),6)
Admitted = rep(c("Y","N"), 12)
Dept = rep(c("A","B","C","D","E","F"), rep(4,6))
mod10.pois = glm(nums~Sex*Dept + Admitted*Dept, family=poisson)
summary(mod10.pois)
Anova(mod10.pois)
require(car)
Anova(mod10.pois)
nums
UCBAdmissions[,,1]
Dept
nums1 = matrix(nums, ncol=2, byrow=T)
nums1
Sex1 = rep(c("M","F"), rep(2,6))
Sex1 = rep(c("M","F"), rep(6,2))
Sex1
Sex1 = rep(c("M","F"), 6)
Dept1 = rep(c("A","B","C","D","E","F"), rep(2,6))
Dept1
mod10.bin = glm(nums1~Sex+Dept1, family=binomial)
mod10.bin = glm(nums1~Sex1+Dept1, family=binomial)
summary(mod10.bin)
Anova(mod10.bin)
Anova(mod10.pois)
z<-c(360,30,310,390,540,70,140,210)
tr<-c(1,2,1,2,1,2,1,2)
h<-c(1,1,2,2,1,1,2,2)
s<-c(1,1,1,1,2,2,2,2) # 1 = survival; 2 = death
g<-glm(z~s*tr+h*tr,family=poisson)
summary(g)
summary(m) # Note that the deviances of m and g are the same, though the null deviances are different
g1<-glm(z~s*tr+s*h+tr*h,family=poisson)
summary(g1)
g2<-glm(z~s*tr*h,family=poisson)
summary(g2)
mod10.pois1 = glm(nums~Sex*Dept*Admitted, family=poisson)
Anova(mod10.pois1)
nums1 = matrix(nums, ncol=2, byrow=T)
Sex1 = rep(c("M","F"), 6)
Dept1 = rep(c("A","B","C","D","E","F"), rep(2,6))
mod10.bin = glm(nums1~Sex1+Dept1, family=binomial)
summary(mod10.bin)
deviance(mod10.pois1)
mod10.pois2 = glm(nums~Sex*Admitted + Dept*Admitted, family=poisson)
deviance(mod10.pois2)
summary(mod10.bin)
deviance(mod10.bin)
deviance(m)
deviance(g)
mod10.bin = glm(nums1~Sex1, family=binomial)
summary(mod10.bin)
mod10.bin = glm(nums1~Dept1, family=binomial)
summary(mod10.bin)
mod10.bin = glm(nums1~Sex1+Dept1, family=binomial)
summary(mod10.bin)
mod10.bin = glm(nums1~Sex1, family=binomial)
summary(mod10.bin)
mod10.pois2 = glm(nums~Sex*Admitted + Dept*Admitted, family=poisson)
deviance(mod10.pois2)
nums1
summary(g)
summary(m) # Note that the deviances of m and g are the same, though the null deviances are different
mod10.pois2 = glm(nums~Admitted*Sex + Dept*Sex, family=poisson)
deviance(mod10.pois2)
Anova(mod10.pois2)
mod10.pois1 = glm(nums~Sex*Dept*Admitted, family=poisson)
Anova(mod10.pois1)
summary(g)

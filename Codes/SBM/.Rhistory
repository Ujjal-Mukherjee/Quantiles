# check if contains origin... if so, assign NA to that depth
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
EPQD.vec[which0] = NA
}
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
return(EPQD.vec)
}
## Empirically calculate PQD with grid search
# Bivariate normal mixture
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=2+c(0,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=2+c(0,0), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=1, mingrid=-6, maxgrid=6)
k = wEPQD(X, sig=2, mingrid=-6, maxgrid=6)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(-2,2), Sigma=sig)
X2 = my.mvrnorm(500, mu=2+c(2,2), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=2, mingrid=-6, maxgrid=6)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(-2,2), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(2,2), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=2, mingrid=-6, maxgrid=6)
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# find scaling mean and cov
b = colMeans(X)
AtA = cov(X)
AtA.inv = solve(cov(X))
X0 = (X-b) %*% AtA.inv
# make grid of points
pts = seq(mingrid, maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
grid0 = (xygrid - b) %*% AtA.inv
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
normsq.X0 = apply(X0^2, 1, sum)
normsq.grid0 = apply(grid0^2, 1, sum)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = as.matrix(rnorm(2)); u = u/sqrt(sum(u^2))
I.minus.Pu = diag(2) - u%*%t(u)
perp.mean = I.minus.Pu %*% b
perp.cov = I.minus.Pu %*% AtA %*% I.minus.Pu
Xuperp = X %*% I.minus.Pu
bperp = b %*% I.minus.Pu
scaled.perp = sqrt(Xuperp^2 %*% ones(ncol(X),1)) - sqrt(sum(bperp^2))
w = dnorm(scaled.perp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w * (X%*%u))
gridperp = xygrid %*% I.minus.Pu
scaled.gridperp = sqrt(gridperp^2 %*% ones(ncol(X),1)) - sqrt(sum(bperp^2))
wu = dnorm(scaled.gridperp, sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu * (xygrid%*%u))
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
# check if contains origin... if so, assign NA to that depth
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
EPQD.vec[which0] = NA
}
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
return(EPQD.vec)
}
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(-2,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(2,0), Sigma=sig2)
X = rbind(X1,X2)
k = wEPQD(X, sig=2, mingrid=-6, maxgrid=6)
k = wEPQD(X, sig=1, mingrid=-6, maxgrid=6)
k = wEPQD(X, sig=.5, mingrid=-6, maxgrid=6)
set.seed(120214)
sig = matrix(c(1,.5,.5,1), nrow=2)
sig2 = matrix(c(1,-.5,-.5,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(-2,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(2,0), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=.5, mingrid=-6, maxgrid=6)
my.mvrnorm = function(n, mu, Sigma){
p = length(mu)
# compute square root of covariance matrix
eo=eigen(Sigma, symmetric=TRUE)
sigma.sqrt=eo$vec%*%diag(eo$val^0.5)%*%t(eo$vec)
# generate random normals from runif by box-muller transform
rnorm.vec = sqrt(-2*log(runif(n*p)))*cos(2*pi*runif(n*p))
# generate sample matrix
sample.matrix = matrix(rep(mu, n), nrow=n, byrow=T) +
matrix(rnorm.vec, nrow=n, ncol=p)%*%sigma.sqrt
return(sample.matrix)
}
ones = function(m,n){
matrix(1, nrow=m, ncol=n)
}
## function to calculate weighted projection quantile depth
wEPQD = function(X, sig, mingrid, maxgrid, res=.2, nu=1e3){
# find scaling mean and cov
b = colMeans(X)
AtA = cov(X)
AtA.inv = solve(cov(X))
X0 = (X-b) %*% AtA.inv
# make grid of points
pts = seq(mingrid, maxgrid, by=res)
lengrid = length(pts)
xcoord = rep(pts, rep(lengrid,lengrid))
ycoord = rep(pts, lengrid)
xygrid = cbind(xcoord,ycoord)
rm(xcoord,ycoord)
grid0 = (xygrid - b) %*% AtA.inv
## get matrix of weighted PQDs for all points
npt = dim(xygrid)[1]
Fuxu.mat = matrix(0, nrow=npt, ncol=nu)
normsq.X0 = apply(X0^2, 1, sum)
normsq.grid0 = apply(grid0^2, 1, sum)
# loop over nu pts on unit circle then take max
for(iu in 1:nu){
u = as.matrix(rnorm(2)); u = u/sqrt(sum(u^2))
I.minus.Pu = diag(2) - u%*%t(u)
perp.mean = I.minus.Pu %*% b
perp.cov = I.minus.Pu %*% AtA %*% I.minus.Pu
Xuperp = X %*% I.minus.Pu
bperp = b %*% I.minus.Pu
scaled.perp = sqrt(Xuperp^2 %*% ones(ncol(X),1))
w = dnorm(scaled.perp, sd=sig)
#w = dcauchy(Xuperp, scale=sig)
uecdf = ecdf(w * (X%*%u))
gridperp = xygrid %*% I.minus.Pu
scaled.gridperp = sqrt(gridperp^2 %*% ones(ncol(X),1))
wu = dnorm(scaled.gridperp, sd=sig)
#wu = dcauchy(sqrt(apply(xygrid^2,1,sum) - xygrid.u^2), scale=sig)
Fuxu.mat[,iu] = uecdf(wu * (xygrid%*%u))
}
EPQD.vec = 1/(1+apply(abs(Fuxu.mat-.5), 1, max))
# check if contains origin... if so, assign NA to that depth
which0 = which(xygrid[,1]==0 & xygrid[,2]==0)
if(length(which0>0)){
EPQD.vec[which0] = NA
}
## plot result
par(mfrow=c(1,2))
persp(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
main="Projection Quantile Depth",
xlab="x1", ylab="x2", zlab="PQD(x,F)",
theta=-45, phi=45)
# contour plot
z = contour(pts, pts, matrix(EPQD.vec, nrow=lengrid, byrow=T),
lwd=2, col="red", nlevels=20)
points(X, pch=19, cex=.2)
par(mfrow=c(1,1))
return(EPQD.vec)
}
## Empirically calculate PQD with grid search
# Bivariate normal mixture
set.seed(120214)
sig = matrix(c(1,.5,.5,1), nrow=2)
sig2 = matrix(c(1,-.5,-.5,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(-2,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(2,0), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=.5, mingrid=-6, maxgrid=6)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(-2,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(2,0), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=.5, mingrid=-6, maxgrid=6)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(0,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(0,0), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=.5, mingrid=-6, maxgrid=6)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=2+c(0,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=2+c(0,0), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=.5, mingrid=-6, maxgrid=6)
k = wEPQD(X, sig=1, mingrid=-6, maxgrid=6)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=4+c(0,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=4+c(0,0), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=1, mingrid=-6, maxgrid=6)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=6+c(0,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=6+c(0,0), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=1, mingrid=-2, maxgrid=10)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=6+c(0,0), Sigma=sig)
X2 = my.mvrnorm(500, mu=6+c(0,0), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=1, mingrid=-2, maxgrid=10)
k = wEPQD(X, sig=10, mingrid=-2, maxgrid=10)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(2,6), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(6,6), Sigma=sig2)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=10, mingrid=-2, maxgrid=10)
k = wEPQD(X, sig=1, mingrid=-2, maxgrid=10)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(2,7), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(6,2), Sigma=sig)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=1, mingrid=-2, maxgrid=10)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(0,7), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(4,2), Sigma=sig)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=1, mingrid=-2, maxgrid=10)
set.seed(120214)
sig = matrix(c(1,.9,.9,1), nrow=2)
sig2 = matrix(c(1,-.9,-.9,1), nrow=2)
X1 = my.mvrnorm(500, mu=c(2,7), Sigma=sig)
X2 = my.mvrnorm(500, mu=c(6,2), Sigma=sig)
X = rbind(X1,X2)
# z = WtProjQuantProfileMod(d,c(0,.9),.1, 1000)
# plot(d)
# lines(z)
k = wEPQD(X, sig=1, mingrid=-2, maxgrid=10)
## PQ/ WPQ-based outliers
setwd("C:/Study/My projects/Quantiles/Codes/SBM")
rm(list=ls());
library(inline)
library(Rcpp)
library(RcppArmadillo)
library(RcppEigen)
library(fda.usc)
sourceCpp("ProjQuantNew1.cpp", verbose=TRUE, rebuild=TRUE);
outlier.score = function(X, type, k=NULL, alpha){
n = nrow(X)
if(is.null(k)){
#k = floor(.1*n)
k = floor(sqrt(n))
}
depth.vec = rep(0,n)
knn.vec = rep(0,n)
# calculate distance matrix for full data
dist.mat = as.matrix(dist(X))
# get depth and knn average dist for all data
for(i in 1:n){
if(type==1){
depth.vec[i] = KernelDepthMod(X[-i,], X[i,], .2)
}
else{
depth.vec[i] = EPQD(X[-i,], X[i,])
}
ik = order(dist.mat[i,])[2:(k+1)]
knn.vec[i] = mean(dist.mat[i,ik])
}
lknn = log(knn.vec)
lhtped = -log(depth.vec)
return(alpha*lknn + (1-alpha)*lhtped)
}
set.seed(11182014)
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(rnorm(50)+10, ncol=2)
Xa = rbind(X1,X2)
cols = c(rep("darkgreen",475), rep("darkred", 25))
# writeup plots
score1 = outlier.score(Xa, type=1, alpha=.05)
score2 = outlier.score(Xa, type=1, alpha=.5)
score3 = outlier.score(Xa, type=1, alpha=.95)
cols = c(rep("green",475), rep("red", 25))
par(mfrow=c(1,3))
plot(score1, col=cols, pch=19, cex=.8,
main="alpha=0.05", ylab="outlier score")
plot(score2, col=cols, pch=19, cex=.8,
main="alpha=0.5", ylab="outlier score")
plot(score3, col=cols, pch=19, cex=.8,
main="alpha=0.95", ylab="outlier score")
par(mfrow=c(1,1))
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(rnorm(50)+sample(c(6:10, -10:-6), 50, replace=T), ncol=2)
label.vec = c(rep("1",475), rep("2", 25))
Xb = rbind(X1,X2)
cols = c(rep("darkgreen",475), rep("darkred", 25))
# writeup plots
score1 = outlier.score(Xb, type=1, alpha=.05)
score2 = outlier.score(Xb, type=1, alpha=.5)
score3 = outlier.score(Xb, type=1, alpha=.95)
cols = c(rep("green",475), rep("red", 25))
par(mfrow=c(1,3))
plot(score1, col=cols, pch=19, cex=.8,
main="alpha=0.05", ylab="outlier score")
plot(score2, col=cols, pch=19, cex=.8,
main="alpha=0.5", ylab="outlier score")
plot(score3, col=cols, pch=19, cex=.8,
main="alpha=0.95", ylab="outlier score")
par(mfrow=c(1,1))
par(mfrow=c(1,2))
plot(Xa, main="Setup 1: clumped outliers",
col=cols, pch=19, cex=.5)
plot(Xb, main="Setup 2: scattered outliers",
col=cols, pch=19, cex=.5)
par(mfrow=c(1,1))
par(mfrow=c(2,2))
plot(lm(stack.loss~., data=stackloss))
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(stackloss[,-4]),
type=1, alpha=.8)
plot(score.vec, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
X = as.matrix(stackloss[,-4])
score1 = outlier.score(X, type=1, alpha=.05)
score2 = outlier.score(X, type=1, alpha=.5)
score3 = outlier.score(X, type=1, alpha=.95)
par(mfrow=c(1,3))
plot(score1, pch=19, cex=.8,
main="alpha=0.05", ylab="outlier score")
plot(score2, pch=19, cex=.8,
main="alpha=0.5", ylab="outlier score")
plot(score3, pch=19, cex=.8,
main="alpha=0.95", ylab="outlier score")
par(mfrow=c(1,1))
require(robustbase)
score.vec = outlier.score(as.matrix(hbk[,-4]),
type=1, alpha=.2)
plot(score.vec, pch=19, cex=.5)
#abline(h=quantile(score.vec,.9), lty=2, lwd=2)
# writeup plots
X = as.matrix(hbk[,-4])
score1 = outlier.score(X, type=1, alpha=.05)
score2 = outlier.score(X, type=1, alpha=.5)
score3 = outlier.score(X, type=1, alpha=.95)
par(mfrow=c(1,3))
plot(score1, pch=19, cex=.8,
main="alpha=0.05", ylab="outlier score"); abline(v=14, lty=2)
plot(score2, pch=19, cex=.8,
main="alpha=0.5", ylab="outlier score"); abline(v=14, lty=2)
plot(score3, pch=19, cex=.8,
main="alpha=0.95", ylab="outlier score"); abline(v=14, lty=2)
par(mfrow=c(1,1))
sourceCpp("ProjQuantNew1.cpp", verbose=TRUE, rebuild=TRUE);
set.seed(11182014)
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(rnorm(50)+10, ncol=2)
Xa = rbind(X1,X2)
cols = c(rep("darkgreen",475), rep("darkred", 25))
# writeup plots
score1 = outlier.score(Xa, type=1, alpha=.05)
score2 = outlier.score(Xa, type=1, alpha=.5)
score3 = outlier.score(Xa, type=1, alpha=.95)
cols = c(rep("green",475), rep("red", 25))
par(mfrow=c(1,3))
plot(score1, col=cols, pch=19, cex=.8,
main="alpha=0.05", ylab="outlier score")
plot(score2, col=cols, pch=19, cex=.8,
main="alpha=0.5", ylab="outlier score")
plot(score3, col=cols, pch=19, cex=.8,
main="alpha=0.95", ylab="outlier score")
par(mfrow=c(1,1))
X1 = matrix(rnorm(950), ncol=2)
X2 = matrix(rnorm(50)+sample(c(6:10, -10:-6), 50, replace=T), ncol=2)
label.vec = c(rep("1",475), rep("2", 25))
Xb = rbind(X1,X2)
cols = c(rep("darkgreen",475), rep("darkred", 25))
# writeup plots
score1 = outlier.score(Xb, type=1, alpha=.05)
score2 = outlier.score(Xb, type=1, alpha=.5)
score3 = outlier.score(Xb, type=1, alpha=.95)
cols = c(rep("green",475), rep("red", 25))
par(mfrow=c(1,3))
plot(score1, col=cols, pch=19, cex=.8,
main="alpha=0.05", ylab="outlier score")
plot(score2, col=cols, pch=19, cex=.8,
main="alpha=0.5", ylab="outlier score")
plot(score3, col=cols, pch=19, cex=.8,
main="alpha=0.95", ylab="outlier score")
par(mfrow=c(1,1))
par(mfrow=c(2,2))
plot(lm(stack.loss~., data=stackloss))
par(mfrow=c(1,1))
score.vec = outlier.score(as.matrix(stackloss[,-4]),
type=1, alpha=.8)
plot(score.vec, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
# writeup plots
X = as.matrix(stackloss[,-4])
score1 = outlier.score(X, type=1, alpha=.05)
score2 = outlier.score(X, type=1, alpha=.5)
score3 = outlier.score(X, type=1, alpha=.95)
par(mfrow=c(1,3))
plot(score1, pch=19, cex=.8,
main="alpha=0.05", ylab="outlier score")
plot(score2, pch=19, cex=.8,
main="alpha=0.5", ylab="outlier score")
plot(score3, pch=19, cex=.8,
main="alpha=0.95", ylab="outlier score")
par(mfrow=c(1,1))
score1
require(robustbase)
score.vec = outlier.score(as.matrix(hbk[,-4]),
type=1, alpha=.2)
plot(score.vec, pch=19, cex=.5)
#abline(h=quantile(score.vec,.9), lty=2, lwd=2)
# writeup plots
X = as.matrix(hbk[,-4])
score1 = outlier.score(X, type=1, alpha=.05)
score2 = outlier.score(X, type=1, alpha=.5)
score3 = outlier.score(X, type=1, alpha=.95)
par(mfrow=c(1,3))
plot(score1, pch=19, cex=.8,
main="alpha=0.05", ylab="outlier score"); abline(v=14, lty=2)
plot(score2, pch=19, cex=.8,
main="alpha=0.5", ylab="outlier score"); abline(v=14, lty=2)
plot(score3, pch=19, cex=.8,
main="alpha=0.95", ylab="outlier score"); abline(v=14, lty=2)
par(mfrow=c(1,1))
require(cepp)
data(Colon)
n = length(Colon$Y)
score.vec = outlier.score(Colon$X, type=1, alpha=.5)
cols = ifelse(Colon$Y==2, "red","green")
plot(score.vec, col=cols, pch=19, cex=.5)
abline(h=quantile(score.vec,.9), lty=2, lwd=2)
abline(h=quantile(score.vec,.1), lty=2, lwd=2)
t.test(depth.vec[which(Colon$Y==1)], depth.vec[which(Colon$Y==2)])
ks.test(depth.vec[which(Colon$Y==1)], depth.vec[which(Colon$Y==2)])
score.vec
